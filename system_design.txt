# High-preformance Communicating Architecture #
# 高性能通信架构 #

## 架构设计 ##
通信模型可分为三层：接入层、汇聚层、核心层；
                                         ____________________ 
                                        |                    |
                                        |   核心业务层       |  
                                        |____________________|    
                                             ^     ^
                            _________________|     |___________________________
                 __________|__________                 ________|_____   _______|______
                |                    |                |              | |              |
                |   区域汇聚服务器   |                |区域汇聚服务器| |区域汇聚服务器|
                |____________________|                |______________| |______________|
                      ^      ^                               ^                 ^        
              ________|      |______                         |                 |               
       ______|______          ______|______             _____|______      _____|_____   
      |             |        |             |           |            |    |           |    
  ==> | 接入服务器  |        | 接入服务器  |           | 接入服务器 |    | 接入服务器|  
      |_____________|        |_____________|           |____________|    |___________|  
            ^ ^                 ^      ^            
        ____| |_____            |      |______     
   ____|____    ____|___     ___|____     ____|___  
  |        |   |        |   |        |   |        | 
  | Client |   | Client |   | Client |   | Client | 
  |________|   |________|   |________|   |________|     
  
 本文描述接入层服务器架构。针对海量接入客户端及高并发特性，采用epoll作为模型驱动器，读写分离。
 
### 功能划分 ###
 主要包括四大模块，以独立线程方式运行：
  接收模块：读取socket数据，并提取消息包分发到各自接收队列。
  发送模块：发送socket数据，把各自发送队列消息打包发送。
  处理模块：处理每个socket接收队列的消息包。
  监控模块：产生定时器、socket的读写事件，增删socket客户端。
  
### 技术特色 ### 
  性能是技术先进性的体现。
  a) 本程序主体运行四个线程，充分适应全双工网卡和多核cpu场景。
  b) 鉴于复杂性及不稳定性，新版本删除了无锁设计，全部采用自旋锁加事件处罚的方式实现数据同步和互斥。
  c) 除消息内存外，初始阶段布局队列、链表内存，增删操作无需额外内存。
  d) socket采用大块读、聚合写的方式，规避系统调用的瓶颈。
  e) 每个socket自有发送/接收两个队列，既保证有序处理，又减少并发损耗。
  f) 采用门设计思路，高效识别队列中的重复事件。
  g) 各线程中内置时间轮超时定时器，由monitor线程以事件方式统一触发超时轮转。
  4线程运行时吞吐量接近 1,000,000 tps，多接入客户端时性能下降平缓。
  
### 整体模型 ###
 消息驱动流程如下图：
                     _______                
             (3)    |       |                
         ---------> |Receive|__________      
        |           |_______|          |     
        |              ^^           (4)|     
        |          (2) ||              |     
      __|____        __||___        ___V___  
     |       |  (1) |       |      |       | 
     | Client| ====>|Monitor|      | Deal  | 
     |_______|      |_______|      |_______| 
         ^             ||              |     
         |          (6)||           (5)|     
         |           __vv___           |     
         |    (7)   |       |          |     
          ----------| Send  |<---------      
                    |_______|    

## 附注 ##
 1) epoll模型是海量接入客户端场景的第一选择；
 本服务器程序优化处理了并发损耗、系统调用瓶颈、海量单体内存布局三大问题，
 是性能提升的关键。在PC虚拟机上达到30万TPS,最小230微秒时延，超过1万每秒的
 连接速率，以及不受限的最大连接数。

 2) 对于汇聚服务器，或者连接数1000以内，单个连接业务量平均几十万TPS的服务器，
  poll模型可以是第一选择。此时，poll提供的按需读/写能力，相比epoll的重复读能力，
  可节省一定的cpu和中断资源。
  
 3) 性能测试部署方式，如下图：
    _______     _______  
   |       |-->|       | 
   | Client|<--| Server| 
   |_______|   |_______| 
   
 4) 测试程序包test_bin.tar.gz包含可在Redhat_X64_7.5版本运行的程序文件，自带帮助信息。运行示例如下：
  以服务器方式运行: ./bin_test 1 10.10.1.10 123456
  以客户端方式运行: ./bin_test 0 10.10.1.10 123456 1 1
